---
title: Chrome의 Back/Forward 캐시가 일으키는 문제와 해결법
date: 2020-10-31
description: Cache-Control 헤더로 Back/Forward 캐시 제어하기
tags:
  - 프론트엔드
---

## 발견한 문제점
회사에서 개발하던 중, 캐시와 관련된 문제가 있었습니다.

뒤로가기와 앞으로가기를 사용해서 사이트를 벗어났다가 다시 들어가는 경우, 최신 데이터를 불러오지 않았습니다.

그래서 Network 탭에서 확인해본 결과, 서버로 요청을 보내지 않고 캐시된 응답을 사용했다는 것을 확인할 수 있었습니다.

하지만 이상했던 점이, 저희 회사는 Cache-Control: no-cache를 활용해서 분명히 캐시를 막아놓았다는 것입니다.

그래서 뒤로가기, 앞으로가기를 할 때 발생하는 백포워드 캐시에 대해서 알아보기 시작했습니다.

## 백포워드 캐시
백포워드 캐시란, 브라우저에서 뒤로가기/앞으로가기(Back/Forward) 이벤트가 발생했을 때, 새롭게 요청을 보내지 않고 캐시해둔 이전 상태를 바로 사용하는 것을 말합니다.

쉽게 말하면 페이지를 일시정지 해두었다가, 돌아갔을 때 다시 재생시키는 것이라고 할 수 있습니다.

## 왜 맘대로 캐시하는가??
정확한 원인은 알 수 없었지만, 로컬에서 많은 테스트를 해보고 내린 결론을 적어보려고 합니다.

### Cache-control: no-cache
Cache-Control: no-cache의 경우, 캐시를 하지 말라는 것이 아닙니다. 캐시를 허용하긴 하지만, 매번 다시 요청을 보내서 만료된 데이터인지 확인하라는 것입니다.

즉, 그런 revalidation 요청에 대한 응답 결과가 캐시된 응답보다 최신이 아닐 경우(변경된 내용이 없는 경우)에만 캐시를 사용하라는 것입니다.

하지만, 백포워드 캐시의 경우 no-cache를 무시했습니다. 새로 요청을 보내지 않고 무조건 디스크 캐시를 사용하고 있었습니다.

max-age, expires 등 여러 옵션을 붙여봐도 결과는 똑같았습니다. 아예 서버로 요청을 보내지 않았습니다.

그래서 시도했던 방법이 Cache-Control: no-store 였습니다.

### Cache-control: no-store
Cache-Control: no-store는 no-cache와 다르게 캐시 자체를 허용하지 않습니다.

Chrome에서 Network 탭을 켜고, disable cache를 설정하는 것과 동일한 역할을 합니다.

실제로 no-store를 사용하거나 disable cache 옵션을 켜주는 경우, 백포워드 캐시가 동작하지 않고 새롭게 요청을 보내는 것을 확인할 수 있었습니다.

## 결론
백포워드 캐시는 no-store 처럼 캐시를 처음부터 거부해버리지 않는 이상, 다른 설정들은 무시하고 동작하는 것 같습니다. (물론 브라우저마다 백포워드 캐시를 구현하지 않거나, 다른 방식으로 동작하게 만들었을 수도 있습니다.)

특정 응답이 백포워드 캐시에 잘못된 영향을 받을 수 있는 경우, Cache-Control: no-store를 꼭 사용해주어야 할 것 같습니다.
